# 리팩토링

- [리팩토링](#리팩토링)
  - [게시글](#-게시글)
    - [게시글 좋아요](#-게시글-좋아요)
    - [게시글 상세보기](#-게시글-상세보기)
    <!-- - [평점](#-평점) -->

## 게시글

### 🧡 게시글 좋아요

<img src="img/capture/게시글 좋아요.png" width=""></img>

'게시글 좋아요 등록, 취소'에 Redis를 도입하여 요청을 1차적으로 처리해 주었습니다.

게시글 좋아요와 북마크 기능은 다수의 사용자가 동시에 동작하여 바로 DB에 insert, update하게될 경우 부하가 생길것으로 판단했습니다.

유저의 좋아요 여부를 판단하여 1차적으로 캐시에 저장했고, 10분마다 캐시에 저장된 내용을 DB로 옮기도록 리팩토링을 진행하였습니다.

Redis의 Set 자료구조를 사용해 'boardLikeAdd::(게시글번호)', 'boardLikeDel::(게시글번호)'을 Key값으로 하고, 유저 아이디를 Value값으로 하여 저장했습니다.

DB로 내용을 옮길 때 set의 size()를 이용해 해당 게시글의 좋아요 수를 누적시켰고, Value값으로 저장되어있는 유저의 정보에 해당 게시글 번호를 저장해주었습니다.

북마크도 좋아요 기능과 같은 방식을 적용하여 리팩토링을 진행하였습니다.

<br>

### 📑 게시글 상세보기

<img src="img/capture/게시글 상세보기.png" width=""></img>

게시글 상세보기를 요청하면 조회수가 늘어나도록 구현되어 있었습니다.

조회수 증가도 좋아요, 북마크와 마찬가지로 바로 DB에 update할 경우 부하가 클 것으로 판단하여 Redis를 도입하여 관리해주었습니다.

조회수는 Redis의 String 자료구조를 사용하여 저장했습니다. 'boardViewCnt::(게시글번호)'를 Key로 하고, Value에 DB에 누적시킬 조회수를 저장했습니다.

```java
public interface BoardForDetailProjectionDto {
	Long getBoardId();
	Long getMovieId();
	String getTitle();
	String getContent();
	LocalDateTime getDateTime();
	String getWriter();
	Long getViewCnt();
	Long getCommentCnt();
	Long getLikeCnt();
}

@Query(value = "select b.board_id as boardId, b.movie_id as movieId, b.title, b.content, b.write_date as dateTime, p.nickname as writer, i.view_cnt, ifnull(c.comment_cnt, 0) as commentCnt, i.like_cnt "
        + "from board as b "
        + "join (select member.member_id, profile.nickname from member join profile on member.profile_id = profile.profile_id) as p "
        + "on b.member_id = p.member_id "
        + "left join (select count(comment_id) as comment_cnt, board_id from board_comment group by board_id) as c "
        + "on b.board_id = c.board_id "
        + "left join board_info as i "
        + "on b.board_info_id = i.board_info_id "
        + "where b.board_id = :boardId"
        , nativeQuery = true)
    BoardForDetailProjectionDto getBoardForDetail(@Param("boardId") Long boardId);

```

projection기능을 도입하여 entity를 전부 가져오는 대신 필요한 속성들만 추출하도록 처리했습니다.

entity를 전부 가져오게 된다면 연관된 테이블의 정보까지 가져오기때문에 속도를 개선하기 위해 projection을 도입하였습니다.

로그인한 유저가 해당 게시글을 좋아요하고있는지 여부는 좋아요 기능에서 만들어놓은 checkLikeStatus 메서드를 재사용하였습니다.

DB에 저장된 좋아요 수와 캐시에 저장된 좋아요 등록, 취소 수를 계산하여 해당 게시글의 좋아요수를 반환하였습니다.
