# 리팩토링

- [리팩토링](#리팩토링)
  - [평점](#-평점)
    - [평점 등록](#-평점-등록)
    <!-- - -->
  - [게시글](#-게시글)
    - [게시글 좋아요](#-게시글-좋아요)
    - [게시글 상세보기](#-게시글-상세보기)

## 평점

### 🎭 평점 등록

<img src="img/capture/평점 등록.png" width=""></img>

'평점 신규 등록' 과 '평점 수정' 으로 API가 분리되어 있었습니다.

두 API를 합쳐 값이 들어오면 신규인지 수정인지 판단하여 처리하도록 하였습니다.

그 이유는 캐시에 저장된 정보를 바탕으로 판단하여 처리하는 것이 더 효율적이라고 판단했습니다. 프론트에서 판단하여 API를 구분해서 넘겨주려면 평점을 조회하는 API를 한번 더 거쳐야 하기 때문입니다.

한 영화의 평점과 관련해서 '조회용 평점 전체 정보', '조회용 개인 유저 평점 정보', 'DB등록용 평점 입력 정보' 에 캐시를 이용하도록 하였습니다.

DB에 잦은 업데이트와 등록요청을 보내기보다 캐시에 모아서 한번에 처리하는 것이 바람직하다고 판단하여 캐시를 이용했습니다.

리팩토링을 진행한 평점 등록 API의 동작 과정은 다음과 같습니다.

1. 해당 영화의 조회용 전체 평점이 캐시에 없다면 생성합니다.

2. 해당 영화의 조회용 개인 유저 평점 정보가 캐시에 없다면 생성합니다.

3. 입력받은 정보를 등록용 캐시에 저장합니다.

   - 캐시에 이미 등록 정보가 있다면 수정합니다.

   - 캐시에 등록된 정보가 없다면 위에서 만든 조회용 정보를 이용해 새로 등록합니다.

<br>

조회용 전체 평점을 만들기 위해서 DB의 정보와 캐시의 등록용 정보를 이용하여 계산했습니다.

캐시의 데이터들을 먼저 계산하고, DB의 정보를 가져올 때는 NOT IN 연산을 통해 캐시에서 이미 꺼낸 유저의 데이터는 가져오지 않도록 구현했습니다.

조회용 평점의 경우 timeout을 설정하여 만료되도록 하였습니다.

```java
private void createTotalRatingCache(long movieId) {
  Long[] result = new Long[7];

  Set<String> redisRatingKeys = redisTemplate.keys("ratingAdd::" + String.valueOf(movieId));
  List<Long> memberList = new ArrayList<>();
  redisRatingKeys.forEach(data -> {
    memberList.add(Long.parseLong(data.split("::")[2]));

    List<String> ratingFromRedis = redisTemplate.opsForList().range(data, 0, 5);
    for (int i = 0; i < 6; i++) {
      result[i] += Long.parseLong(ratingFromRedis.get(5 - i));
    }
  });
  result[6] += redisRatingKeys.size();

  List<RatingEntity> dbList = ratingCustomRepository.getRatingNotInList(movieId, memberList);
  dbList.forEach(data -> {
    result[0] += data.getTotal();
    result[1] += data.getSound();
    result[2] += data.getVisual();
    result[3] += data.getDirection();
    result[4] += data.getActing();
    result[5] += data.getStory();
  });
  result[6] += dbList.size();

  String totalKey = "ratingTotal::" + movieId;
  ListOperations listOperations = redisTemplate.opsForList();
  for (int i = 6; i >= 0; i--) {
    listOperations.leftPush(totalKey, String.valueOf(result[i]));
  }
  listOperations.getOperations().expire(totalKey, Duration.ofMinutes(5));
}
```

<br>

캐시에 저장된 등록용 정보는 일정 주기마다 DB에 저장해주었습니다.

'ratingAdd'로 시작하는 데이터를 가져와서 영화id와 유저id를 얻고, 저장된 평점을 해당 유저, 해당 영화에 저장했습니다.

DB에 평점이 저장되어 있는 경우 dirty checking을 통해 수정해주었고, 새로 등록하는 경우 정보들을 List에 모아서 saveAll을 통해 한번에 처리했습니다.

```java
@Transactional
@Scheduled(cron = "0 0/7 * * * ?")
public void deleteRatingCacheFromRedis() {
    log.info("캐시에서 평점 정보 DB로 저장");
    List<RatingEntity> ratingList = new ArrayList<>();
    Set<String> redisRatingKeys = redisTemplate.keys("ratingAdd*");
    redisRatingKeys.forEach(data -> {
        Long movieId = Long.parseLong(data.split("::")[1]);
        Long userId = Long.parseLong(data.split("::")[2]);
        List<String> ratingFromRedis = redisTemplate.opsForList().range(data, 0, 5);
        RatingEntity myRating = ratingRepository.findPersonal(movieId, userId);
        if(myRating == null) {
            RatingEntity newRating = RatingEntity.builder()
                .story(Long.parseLong(ratingFromRedis.get(0).toString()))
                .acting(Long.parseLong(ratingFromRedis.get(1).toString()))
                .direction(Long.parseLong(ratingFromRedis.get(2).toString()))
                .visual(Long.parseLong(ratingFromRedis.get(3).toString()))
                .sound(Long.parseLong(ratingFromRedis.get(4).toString()))
                .total(Long.parseLong(ratingFromRedis.get(5).toString()))
                .movie(movieRepository.findById(movieId).get())
                .member(memberRepository.findById(userId).get())
                .build();
            ratingList.add(newRating);
        }else {
            myRating.changeRating(ratingFromRedis);
        }

        redisTemplate.delete(data);
    });

    ratingRepository.saveAll(ratingList);
}
```

## 게시글

### 🧡 게시글 좋아요

<img src="img/capture/게시글 좋아요.png" width=""></img>

'게시글 좋아요 등록, 취소'에 Redis를 도입하여 요청을 1차적으로 처리해 주었습니다.

게시글 좋아요와 북마크 기능은 다수의 사용자가 동시에 동작하여 바로 DB에 insert, update하게될 경우 부하가 생길것으로 판단했습니다.

유저의 좋아요 여부를 판단하여 1차적으로 캐시에 저장했고, 10분마다 캐시에 저장된 내용을 DB로 옮기도록 리팩토링을 진행하였습니다.

Redis의 Set 자료구조를 사용해 'boardLikeAdd::(게시글번호)', 'boardLikeDel::(게시글번호)'을 Key값으로 하고, 유저 아이디를 Value값으로 하여 저장했습니다.

DB로 내용을 옮길 때 set의 size()를 이용해 해당 게시글의 좋아요 수를 누적시켰고, Value값으로 저장되어있는 유저의 정보에 해당 게시글 번호를 저장해주었습니다.

북마크도 좋아요 기능과 같은 방식을 적용하여 리팩토링을 진행하였습니다.

<br>

해당 유저가 해당 게시글을 좋아요 누른 상태인지 확인하는 메서드를 만들었습니다. 게시글 상세보기와 같은 몇 가지 API에서 재사용이 가능할 것으로 판단했기 때문입니다.

DB의 정보와 캐시의 좋아요를 등록한 경우, 취소한 경우를 통해 좋아요 여부를 확인하였습니다.

```java
/**
 * 게시글 좋아요 여부 확인
 */
private boolean checkLikeStatus(String boardLike, Long userId, Long boardId) {
    String keyAdd = "boardLikeAdd::" + boardId;
    String keyDel = "boardLikeDel::" + boardId;
    SetOperations<String, String> setOperations = redisTemplate.opsForSet();

    if(setOperations.isMember(keyAdd, String.valueOf(userId))) {
        return true;
    }else if(setOperations.isMember(keyDel, String.valueOf(userId))) {
        return false;
    }else if(boardLike != null && boardLike.contains(String.valueOf(boardId))) {
        return true;
    }
    return false;
}
```

<br>

좋아요 등록, 취소의 경우는 유저가 쉽게, 여러번 누를 수 있는 기능이고, 여러 유저의 동작으로 DB에 많은 부담을 줄 수 있다고 판단하여 캐시에 모아 한번에 처리하도록 하였습니다.

```java
/**
 * 캐시에서 게시글 좋아요 정보 DB로 저장
 */
@Transactional
@Scheduled(cron = "0 0/10 * * * ?")
public void deleteLikeCacheFromRedis() {
    log.info("캐시에서 게시글 좋아요 정보 DB로 저장");
    Set<String> redisLikeKeys = redisTemplate.keys("boardLikeAdd*");
    Objects.requireNonNull(redisLikeKeys).forEach(data -> {
        Long boardId = Long.parseLong(data.split("::")[1]);
        Long cnt = redisTemplate.opsForSet().size(data);
        Board board = boardRepository.findById(boardId).get();
        board.getBoardInfo().addLikeCnt(cnt);

        Set<String> redisUsers = redisTemplate.opsForSet().members(data);
        redisUsers.stream().forEach(user -> {
            Long userId = Long.parseLong(user);
            Optional<Member> member = memberRepository.findById(userId);
            String s = member.get().getMemberInfo().getLikeBoard() + boardId + ",";
            member.get().getMemberInfo().setLikeBoard(s);
            redisTemplate.opsForSet().remove(data, user);
        });
    });

    redisLikeKeys = redisTemplate.keys("boardLikeDel*");
    Objects.requireNonNull(redisLikeKeys).forEach(data -> {
        Long boardId = Long.parseLong(data.split("::")[1]);
        Long cnt = redisTemplate.opsForSet().size(data);
        Board board = boardRepository.findById(boardId).get();
        board.getBoardInfo().subtractLikeCnt(cnt);

        Set<String> redisUsers = redisTemplate.opsForSet().members(data);
        redisUsers.stream().forEach(user -> {
            Long userId = Long.parseLong(user);
            Optional<Member> member = memberRepository.findById(userId);
            StringBuilder sb = new StringBuilder(member.get().getMemberInfo().getLikeBoard());
            String s = boardId + ",";
            sb.delete(sb.indexOf(s), sb.indexOf(s) + s.length());
            member.get().getMemberInfo().setLikeBoard(sb.toString());
            redisTemplate.opsForSet().remove(data, user);
        });
    });
}
```

<br>

### 📑 게시글 상세보기

<img src="img/capture/게시글 상세보기.png" width=""></img>

게시글 상세보기를 요청하면 조회수가 늘어나도록 구현되어 있었습니다.

조회수 증가도 좋아요, 북마크와 마찬가지로 바로 DB에 update할 경우 부하가 클 것으로 판단하여 Redis를 도입하여 관리해주었습니다.

조회수는 Redis의 String 자료구조를 사용하여 저장했습니다. 'boardViewCnt::(게시글번호)'를 Key로 하고, Value에 DB에 누적시킬 조회수를 저장했습니다.

로그인한 유저가 해당 게시글을 좋아요하고있는지 여부는 좋아요 기능에서 만들어놓은 checkLikeStatus 메서드를 재사용하였습니다.

DB에 저장된 좋아요 수와 캐시에 저장된 좋아요 등록, 취소 수를 계산하여 해당 게시글의 좋아요수를 반환하였습니다.

<br>

projection기능을 도입하여 entity를 전부 가져오는 대신 필요한 속성들만 추출하도록 처리했습니다.

entity를 전부 가져오게 된다면 연관된 테이블의 정보까지 가져오기때문에 속도를 개선하기 위해 projection을 도입하였습니다.

```java
public BoardForDetailProjectionDto getBoardForDetail(Long boardId) {
  return queryFactory
    .select(Projections.constructor(BoardForDetailProjectionDto.class,
      board.id.as("boardId"),
      board.movie.id.as("movieId"),
      board.title,
      board.content,
      board.dateTime,
      member.profile.nickname.as("writer"),
      boardInfo.viewCnt.coalesce(0L).as("viewCnt"),
      boardComment.id.count().coalesce(0L).as("commentCnt"),
      boardInfo.likeCnt.coalesce(0L).as("likeCnt")
      ))
    .from(board)
    .join(board.member, member)
    .leftJoin(board.boardComments, boardComment)
    .leftJoin(board.boardInfo, boardInfo)
    .where(board.id.eq(boardId))
    .fetchOne();
}
```

<br>

게시글 조회수의 경우 클릭 한번으로 1씩 증가시켜야하기 때문에 잦은 update요청을 하기 보다는 캐시에 모아놓고 일정 주기마다 DB에 한번에 update하였습니다.

```java
/**
 * 캐시에서 게시글 조회수 정보 DB로 저장
 */
@Transactional
@Scheduled(cron = "0 0/3 * * * ?")
public void deleteViewCntCacheFromRedis() {
    log.info("캐시에서 게시글 조회수 정보 DB로 저장");
    Set<String> redisKeys = redisTemplate.keys("boardViewCnt*");
    Objects.requireNonNull(redisKeys).forEach(data -> {
        Long boardId = Long.parseLong(data.split("::")[1]);
        Board board = boardRepository.findById(boardId).get();
        Long viewCnt = board.getBoardInfo().getViewCnt();
        viewCnt += Long.parseLong(redisTemplate.opsForValue().get(data).toString());
        board.getBoardInfo().setViewCnt(viewCnt);
        redisTemplate.delete(data);
    });
}
```
